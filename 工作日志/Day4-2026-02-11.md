# Day 4 — 2026-02-11 — Phase 4: 手动构建 StateGraph

## 今日目标

替换 `create_agent` 高层封装，用 LangGraph `StateGraph` 手动构建 Agent 图，并加入查询改写和工具调用上限两项增强。

## 完成内容

### 1. 手动 StateGraph (`agent/graph.py`)

- [x] **自定义状态** `AgentState`（`messages` + `iteration_count`）
- [x] **6 个节点**:
  - `trim` — 裁剪消息历史到最近 N 条，重置迭代计数
  - `rewrite` — 查询改写，短问题(<6字)或含代词时 LLM 改写
  - `agent` — 注入 system_prompt + 调用 `llm.bind_tools(tools)`
  - `tools` — `ToolNode(tools)` 执行工具调用
  - `increment` — 工具调用轮数 +1
  - `force_reply` — 超过上限后用不绑定工具的 LLM 强制回答
- [x] **2 个条件路由**:
  - `should_continue` — 有 tool_calls → tools，否则 → END
  - `check_iterations` — <5 轮 → continue，>=5 轮 → force_reply
- [x] **构建函数** `build_agent(llm, tools, checkpointer, system_prompt, max_messages, max_iterations)`

### 2. main.py 双模式支持

- [x] `python main.py` — 默认使用手动 StateGraph 模式
- [x] `python main.py --classic` — 使用原来的 create_agent 封装
- [x] 使用 `argparse` 解析参数
- [x] CLI 循环、token 统计、线程切换等代码完全共用

### 3. 清理 Git

- [x] 提交清理误提交的数据库和向量备份文件

## 图结构

```
START → trim → rewrite → agent → should_continue
                                    ├─ "tools" → tools → increment → check_iterations
                                    │                                   ├─ "continue" → agent
                                    │                                   └─ "limit" → force_reply → END
                                    └─ END
```

## 最终项目结构变化

```
e:\MyAgent\
├── agent/
│   ├── graph.py            ← Day 4 新增（手动 StateGraph）
│   ├── rag/
│   └── memory/
├── main.py                 ← Day 4 更新（argparse + 双模式）
```

## 关键代码变更

### agent/graph.py (新建)
- `AgentState(TypedDict)` — 扩展 MessagesState，增加 `iteration_count`
- `build_agent()` — 构建完整图并 compile
- 查询改写触发条件: `len(query) < 6` 或包含代词 `那个/这个/它/之前` 等
- 工具调用上限默认 5 轮，`force_reply` 用不绑定工具的 LLM 确保不再调工具

### main.py (修改)
- 新增 `_build_classic_agent()` 和 `_build_graph_agent()` 两个构建函数
- `--classic` flag 选择模式
- 启动时显示当前模式名称

## 学到的东西

- `StateGraph` 需要明确定义状态类型（TypedDict），比 MessagesState 更灵活
- `add_messages` 注解器让 messages 自动追加而非覆盖
- `ToolNode` 是 langgraph.prebuilt 提供的工具执行节点，省去手动遍历 tool_calls
- `bind_tools()` vs 不绑定：force_reply 用不绑定工具的 LLM 确保不会再调工具
- 条件路由 `add_conditional_edges` 的 mapping 需要覆盖所有可能返回值

## 下一步

Phase 5 — 深入 RAG 管线（自定义分块、检索优化、hybrid search）
